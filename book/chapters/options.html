
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Options Â· CLI11 Tutorial</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="Henry Schreiner">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-term/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-hints/plugin-hints.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="validators.html" />
    
    
    <link rel="prev" href="flags.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="installation.html">
            
                <a href="installation.html">
            
                    
                    Installation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="basics.html">
            
                <a href="basics.html">
            
                    
                    Basics
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="flags.html">
            
                <a href="flags.html">
            
                    
                    Flags
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.5" data-path="options.html">
            
                <a href="options.html">
            
                    
                    Options
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="validators.html">
            
                <a href="validators.html">
            
                    
                    Validators
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="subcommands.html">
            
                <a href="subcommands.html">
            
                    
                    Subcommands and the App
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="an-advanced-example.html">
            
                <a href="an-advanced-example.html">
            
                    
                    An advanced example
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="config.html">
            
                <a href="config.html">
            
                    
                    Configuration files
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="formatting.html">
            
                <a href="formatting.html">
            
                    
                    Formatting help output
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="toolkits.html">
            
                <a href="toolkits.html">
            
                    
                    Toolkits
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="advanced-topics.html">
            
                <a href="advanced-topics.html">
            
                    
                    Advanced topics
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="internals.html">
            
                <a href="internals.html">
            
                    
                    Internals
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Options</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="options">Options</h1>
<h2 id="simple-options">Simple options</h2>
<p>The most versatile addition to a command line program is a option. This is like a flag, but it takes an argument. CLI11 handles all the details for many types of options for you, based on their type. To add an option:</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">int</span> int_option{<span class="hljs-number">0</span>};
app.add_option(<span class="hljs-string">&quot;-i&quot;</span>, int_option, <span class="hljs-string">&quot;Optional description&quot;</span>);
</code></pre>
<p>This will bind the option <code>-i</code> to the integer <code>int_option</code>. On the command line, a single value that can be converted to an integer will be expected. Non-integer results will fail. If that option is not given, CLI11 will not touch the initial value. This allows you to set up defaults by simply setting your value beforehand. If you want CLI11 to display your default value, you can add the optional final argument <code>true</code> when you add the option.</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">int</span> int_option{<span class="hljs-number">0</span>};
app.add_option(<span class="hljs-string">&quot;-i&quot;</span>, int_option, <span class="hljs-string">&quot;Optional description&quot;</span>, <span class="hljs-literal">true</span>);
</code></pre>
<p>You can use any C++ int-like type, not just <code>int</code>. CLI11 understands the following categories of types:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>CLI11</th>
</tr>
</thead>
<tbody>
<tr>
<td>number like</td>
<td>Integers, floats, bools, or any type that can be constructed from an integer or floating point number</td>
</tr>
<tr>
<td>string-like</td>
<td>std\::string, or anything that can be constructed from or assigned a std\::string</td>
</tr>
<tr>
<td>char</td>
<td>For a single char, single string values are accepted, otherwise longer strings are treated as integral values and a conversion is attempted</td>
</tr>
<tr>
<td>complex-number</td>
<td>std::complex or any type which has a real(), and imag() operations available, will allow 1 or 2 string definitions like &quot;1+2j&quot; or two arguments &quot;1&quot;,&quot;2&quot;</td>
</tr>
<tr>
<td>enumeration</td>
<td>any enum or enum class type is supported through conversion from the underlying type(typically int, though it can be specified otherwise)</td>
</tr>
<tr>
<td>container-like</td>
<td>a container(like vector) of any available types including other containers</td>
</tr>
<tr>
<td>wrapper</td>
<td>any other object with a <code>value_type</code> static definition where the type specified by <code>value_type</code> is one of type in this list</td>
</tr>
<tr>
<td>tuple</td>
<td>a tuple, pair, or array, or other type with a tuple size and tuple_type operations defined and the members being a type contained in this list</td>
</tr>
<tr>
<td>function</td>
<td>A function that takes an array of strings and returns a string that describes the conversion failure or empty for success. May be the empty function. (<code>{}</code>)</td>
</tr>
<tr>
<td>streamable</td>
<td>any other type with a <code>&lt;&lt;</code> operator will also work</td>
</tr>
</tbody>
</table>
<p>By default, CLI11 will assume that an option is optional, and one value is expected if you do not use a vector. You can change this on a specific option using option modifiers.</p>
<h2 id="positional-options-and-aliases">Positional options and aliases</h2>
<p>When you give an option on the command line without a name, that is a positional option. Positional options are accepted in the same order they are defined. So, for example:</p>
<pre><code class="lang-term"><pre class="term t-default t-fade"><button class="btn t-copy" data-clipboard-text="./a.out one --two three four"><svg class="octicon octicon-clippy" viewbox="0 0 14 16" version="1.1" width="14" height="14" aria-hidden="true"><path fill-rule="evenodd" d="M2 13h4v1H2v-1zm5-6H2v1h5V7zm2 3V8l-3 3 3 3v-2h5v-2H9zM4.5 9H2v1h2.5V9zM2 12h2.5v-1H2v1zm9 1h1v2c-.02.28-.11.52-.3.7-.19.18-.42.28-.7.3H1c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1h3c0-1.11.89-2 2-2 1.11 0 2 .89 2 2h3c.55 0 1 .45 1 1v5h-1V6H1v9h10v-2zM2 5h8c0-.55-.45-1-1-1H8c-.55 0-1-.45-1-1s-.45-1-1-1-1 .45-1 1-.45 1-1 1H3c-.55 0-1 .45-1 1z"/></svg></button><span class="t-line t-prompt-line"><span class="t-prompt">gitbook</span><span class="t-pathsep">:</span><span class="t-path">examples </span><span class="t-delimiter">$ </span><span class="t-command">./a.out one --two three four</span>
</span></pre></code></pre>
<p>The string <code>one</code> would have to be the first positional option. If <code>--two</code> is a flag, then the remaining two strings are positional. If <code>--two</code> is a one-argument option, then <code>four</code> is the second positional. If <code>--two</code> accepts two or more arguments, then there are no more positionals.</p>
<p>To make a positional option, you simply give CLI11 one name that does not start with a dash. You can have as many (non-overlapping) names as you want for an option, but only one positional name. So the following name string is valid:</p>
<pre><code class="lang-cpp"><span class="hljs-string">&quot;-a,-b,--alpha,--beta,mypos&quot;</span>
</code></pre>
<p>This would make two short option aliases, two long option alias, and the option would be also be accepted as a positional.</p>
<h2 id="containers-of-options">Containers of options</h2>
<p>If you use a vector or other container instead of a plain option, you can accept more than one value on the command line. By default, a container accepts as many options as possible, until the next value that could be a valid option name. You can specify a set number using an option modifier <code>-&gt;expected(N)</code>. (The default unlimited behavior on vectors is restored with <code>N=-1</code>) CLI11 does not differentiate between these two methods for unlimited acceptance options.</p>
<table>
<thead>
<tr>
<th>Separate names</th>
<th>Combined names</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--vec 1 --vec 2</code></td>
<td><code>--vec 1 2</code></td>
</tr>
</tbody>
</table>
<p>It is also possible to specify a minimum and maximum number through <code>-&gt;expected(Min,Max)</code>.  It is also possible to specify a min and max type size for the elements of the container.  It most cases these values will be automatically determined but a user can manually restrict them.</p>
<p>An example of setting up a vector option:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; int_vec;
app.add_option(<span class="hljs-string">&quot;--vec&quot;</span>, int_vec, <span class="hljs-string">&quot;My vector option&quot;</span>);
</code></pre>
<p>Vectors will be replaced by the parsed content if the option is given on the command line.</p>
<p>A definition of a container for purposes of CLI11 is a type with a <code>end()</code>, <code>insert(...)</code>, <code>clear()</code> and <code>value_type</code> definitions.  This includes <code>vector</code>, <code>set</code>, <code>deque</code>, <code>list</code>, <code>forward_iist</code>, <code>map</code>, <code>unordered_map</code> and a few others from the standard library, and many other containers from the boost library.</p>
<h3 id="containers-of-containers">containers of containers</h3>
<p>Containers of containers are also supported.</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; int_vec;
app.add_option(<span class="hljs-string">&quot;--vec&quot;</span>, int_vec, <span class="hljs-string">&quot;My vector of vectors option&quot;</span>);
</code></pre>
<p>CLI11 inserts a separator sequence at the start of each argument call to separate the vectors.  So unless the separators are injected as part of the command line each call of the option on the command line will result in a separate element of the outer vector.  This can be manually controlled via <code>inject_separator(true|false)</code> but in nearly all cases this should be left to the defaults.  To insert of a separator from the command line add a <code>%%</code> where the separation should occur.</p>
<pre><code>cmd --vec_of_vec 1 2 3 4 %% 1 2
</code></pre><p>would then result in a container of size 2 with the first element containing 4 values and the second 2.</p>
<p>This separator is also the only way to get values into something like</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; two_vecs;
app.add_option(<span class="hljs-string">&quot;--vec&quot;</span>, two_vecs, <span class="hljs-string">&quot;pair of vectors&quot;</span>);
</code></pre>
<p>without calling the argument twice.</p>
<p>Further levels of nesting containers should compile but intermediate layers will only have a single element in the container, so is probably not that useful.</p>
<h3 id="nested-types">Nested types</h3>
<p>Types can be nested For example</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-built_in">map</span>;
app.add_option(<span class="hljs-string">&quot;--dict&quot;</span>, <span class="hljs-built_in">map</span>, <span class="hljs-string">&quot;map of pairs&quot;</span>);
</code></pre>
<p>will require 3 arguments for each invocation, and multiple sets of 3 arguments can be entered for a single invocation on the command line.</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&gt;&gt; <span class="hljs-built_in">map</span>;
app.add_option(<span class="hljs-string">&quot;--dict&quot;</span>, <span class="hljs-built_in">map</span>, <span class="hljs-string">&quot;map of pairs&quot;</span>);
</code></pre>
<p>will result in a requirement for 2 integers on each invocation and absorb an unlimited number of strings including 0.</p>
<h2 id="option-modifiers">Option modifiers</h2>
<p>When you call <code>add_option</code>, you get a pointer to the added option. You can use that to add option modifiers. A full listing of the option modifiers:</p>
<table>
<thead>
<tr>
<th>Modifier</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-&gt;required()</code></td>
<td>The program will quit if this option is not present. This is <code>mandatory</code> in Plumbum, but required options seems to be a more standard term. For compatibility, <code>-&gt;mandatory()</code> also works.</td>
</tr>
<tr>
<td><code>-&gt;expected(N)</code></td>
<td>Take <code>N</code> values instead of as many as possible, mainly for vector args.</td>
</tr>
<tr>
<td><code>-&gt;expected(Nmin,Nmax)</code></td>
<td>Take between <code>Nmin</code> and <code>Nmax</code> values.</td>
</tr>
<tr>
<td><code>-&gt;type_size(N)</code></td>
<td>specify that each block of values would consist of N elements</td>
</tr>
<tr>
<td><code>-&gt;type_size(Nmin,Nmax)</code></td>
<td>specify that each block of values would consist of between Nmin and Nmax elements</td>
</tr>
<tr>
<td><code>-&gt;needs(opt)</code></td>
<td>This option requires another option to also be present, opt is an <code>Option</code> pointer.</td>
</tr>
<tr>
<td><code>-&gt;excludes(opt)</code></td>
<td>This option cannot be given with <code>opt</code> present, opt is an <code>Option</code> pointer.</td>
</tr>
<tr>
<td><code>-&gt;envname(name)</code></td>
<td>Gets the value from the environment if present and not passed on the command line.</td>
</tr>
<tr>
<td><code>-&gt;group(name)</code></td>
<td>The help group to put the option in. No effect for positional options. Defaults to <code>&quot;Options&quot;</code>. <code>&quot;Hidden&quot;</code> will not show up in the help print.</td>
</tr>
<tr>
<td><code>-&gt;description(string)</code></td>
<td>Set/change the description</td>
</tr>
<tr>
<td><code>-&gt;ignore_case()</code></td>
<td>Ignore the case on the command line (also works on subcommands, does not affect arguments).</td>
</tr>
<tr>
<td><code>-&gt;ignore_underscore()</code></td>
<td>Ignore any underscores on the command line (also works on subcommands, does not affect arguments).</td>
</tr>
<tr>
<td><code>-&gt;allow_extra_args()</code></td>
<td>Allow extra argument values to be included when an option is passed. Enabled by default for vector options.</td>
</tr>
<tr>
<td><code>-&gt;disable_flag_override()</code></td>
<td>specify that flag options cannot be overridden on the command line use <code>=&lt;newval&gt;</code></td>
</tr>
<tr>
<td><code>-&gt;delimiter(&apos;&lt;CH&gt;&apos;)</code></td>
<td>specify a character that can be used to separate elements in a command line argument, default is <none>, common values are &apos;,&apos;, and &apos;;&apos;</none></td>
</tr>
<tr>
<td><code>-&gt;multi_option_policy( CLI::MultiOptionPolicy::Throw)</code></td>
<td>Sets the policy for handling multiple arguments if the option was received on the command line several times. <code>Throw</code>ing an error is the default, but <code>TakeLast</code>, <code>TakeFirst</code>, <code>TakeAll</code>, and <code>Join</code> are also available. See the next four lines for shortcuts to set this more easily.</td>
</tr>
<tr>
<td><code>-&gt;take_last()</code></td>
<td>Only use the last option if passed several times. This is always true by default for bool options, regardless of the app default, but can be set to false explicitly with <code>-&gt;multi_option_policy()</code>.</td>
</tr>
<tr>
<td><code>-&gt;take_first()</code></td>
<td>sets <code>-&gt;multi_option_policy(CLI::MultiOptionPolicy::TakeFirst)</code></td>
</tr>
<tr>
<td><code>-&gt;take_all()</code></td>
<td>sets <code>-&gt;multi_option_policy(CLI::MultiOptionPolicy::TakeAll)</code></td>
</tr>
<tr>
<td><code>-&gt;join()</code></td>
<td>sets <code>-&gt;multi_option_policy(CLI::MultiOptionPolicy::Join)</code>, which uses newlines or the specified delimiter to join all arguments into a single string output.</td>
</tr>
<tr>
<td><code>-&gt;join(delim)</code></td>
<td>sets <code>-&gt;multi_option_policy(CLI::MultiOptionPolicy::Join)</code>, which uses <code>delim</code> to join all arguments into a single string output. this also sets the delimiter</td>
</tr>
<tr>
<td><code>-&gt;check(Validator)</code></td>
<td>perform a check on the returned results to verify they meet some criteria. See <a href="validators.html">Validators</a> for more info</td>
</tr>
<tr>
<td><code>-&gt;transform(Validator)</code></td>
<td>Run a transforming validator on each value passed. See <a href="validators.html">Validators</a> for more info</td>
</tr>
<tr>
<td><code>-&gt;each(void(std::string))</code></td>
<td>Run a function on each parsed value, <em>in order</em>.</td>
</tr>
<tr>
<td><code>-&gt;default_str(string)</code></td>
<td>set a default string for use in the help and as a default value if no arguments are passed and a value is requested</td>
</tr>
<tr>
<td><code>-&gt;default_function(string())</code></td>
<td>Advanced: Change the function that <code>capture_default_str()</code> uses.</td>
</tr>
<tr>
<td><code>-&gt;default_val(value)</code></td>
<td>Generate the default string from a value and validate that the value is also valid.  For options that assign directly to a value type the value in that type is also updated.  Value must be convertible to a string(one of known types or have a stream operator).</td>
</tr>
</tbody>
</table>
<p>The <code>-&gt;check(...)</code> and <code>-&gt;transform(...)</code> modifiers can also take a callback function of the form <code>bool function(std::string)</code> that runs on every value that the option receives, and returns a value that tells CLI11 whether the check passed or failed.</p>
<h2 id="using-the-clioption-pointer">Using the <code>CLI::Option</code> pointer</h2>
<p>Each of the option creation mechanisms returns a pointer to the internally stored option. If you save that pointer, you can continue to access the option, and change setting on it later. The Option object can also be converted to a bool to see if it was passed, or <code>-&gt;count()</code> can be used to see how many times the option was passed. Since flags are also options, the same methods work on them.</p>
<pre><code class="lang-cpp">CLI::Option* opt = app.add_flag(<span class="hljs-string">&quot;--opt&quot;</span>);

CLI11_PARSE(app, argv, argc);

<span class="hljs-keyword">if</span>(* opt)
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Flag received &quot;</span> &lt;&lt; opt-&gt;count() &lt;&lt; <span class="hljs-string">&quot; times.&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
</code></pre>
<h2 id="inheritance-of-defaults">Inheritance of defaults</h2>
<p>One of CLI11&apos;s systems to allow customizability without high levels of verbosity is the inheritance system. You can set default values on the parent <code>App</code>, and all options and subcommands created from it remember the default values at the point of creation. The default value for Options, specifically, are accessible through the <code>option_defaults()</code> method. There are a number of settings that can be set and inherited:</p>
<ul>
<li><code>group</code>: The group name starts as &quot;Options&quot;</li>
<li><code>required</code>: If the option must be given. Defaults to <code>false</code>. Is ignored for flags.</li>
<li><code>multi_option_policy</code>: What to do if several copies of an option are passed and one value is expected. Defaults to <code>CLI::MultiOptionPolicy::Throw</code>. This is also used for bool flags, but they always are created with the value <code>CLI::MultiOptionPolicy::TakeLast</code> regardless of the default, so that multiple bool flags does not cause an error. But you can override that flag by flag.</li>
<li><code>ignore_case</code>: Allow any mixture of cases for the option or flag name</li>
<li><code>ignore_underscore</code>: Allow any number of underscores in the option or flag name</li>
<li><code>configurable</code>:  Specify whether an option can be configured through a config file</li>
<li><code>disable_flag_override</code>:  do not allow flag values to be overridden on the command line</li>
<li><code>always_capture_default</code>:  specify that the default values should be automatically captured.</li>
<li><code>delimiter</code>:  A delimiter to use for capturing multiple values in a single command line string (e.g. --flag=&quot;flag,-flag2,flag3&quot;)</li>
</ul>
<p>An example of usage:</p>
<pre><code>app.option_defaults()-&gt;ignore_case()-&gt;group(&quot;Required&quot;);

app.add_flag(&quot;--CaSeLeSs&quot;);
app.get_group() // is &quot;Required&quot;
</code></pre><p>Groups are mostly for visual organization, but an empty string for a group name will hide the option.</p>
<h3 id="windows-style-options">Windows style options</h3>
<p>You can also set the app setting <code>app-&gt;allow_windows_style_options()</code> to allow windows style options to also be recognized on the command line:</p>
<ul>
<li><code>/a</code> (flag)</li>
<li><code>/f filename</code> (option)</li>
<li><code>/long</code> (long flag)</li>
<li><code>/file filename</code> (space)</li>
<li><code>/file:filename</code> (colon)</li>
<li><code>/long_flag:false</code> (long flag with : to override the default value)</li>
</ul>
<p>Windows style options do not allow combining short options or values not separated from the short option like with <code>-</code> options. You still specify option names in the same manner as on Linux with single and double dashes when you use the <code>add_*</code> functions, and the Linux style on the command line will still work. If a long and a short option share the same name, the option will match on the first one defined.</p>
<h2 id="parse-configuration">Parse configuration</h2>
<p>How an option and its arguments are parsed depends on a set of controls that are part of the option structure.  In most circumstances these controls are set automatically based on the type or function used to create the option and the type the arguments are parsed into.  The variables define the size of the underlying type (essentially how many strings make up the type), the expected size (how many groups are expected) and a flag indicating if multiple groups are allowed with a single option.  And these interact with the <code>multi_option_policy</code> when it comes time to parse.</p>
<h3 id="examples">examples</h3>
<p>How options manage this is best illustrated through some examples</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> val;
app.add_option(<span class="hljs-string">&quot;--opt&quot;</span>,val,<span class="hljs-string">&quot;description&quot;</span>);
</code></pre>
<p>creates an option that assigns a value to a <code>std::string</code>  When this option is constructed it sets a type_size min and max of 1.  Meaning that the assignment uses a single string.  The Expected size is also set to 1 by default, and <code>allow_extra_args</code> is set to false. meaning that each time this option is called 1 argument is expected.  This would also be the case if val were a <code>double</code>, <code>int</code> or any other single argument types.</p>
<p>now for example</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; val;
app.add_option(<span class="hljs-string">&quot;--opt&quot;</span>,val,<span class="hljs-string">&quot;description&quot;</span>);
</code></pre>
<p>In this case the typesize is automatically detected to be 2 instead of 1, so the parsing would expect 2 arguments associated with the option.</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; val;
app.add_option(<span class="hljs-string">&quot;--opt&quot;</span>,val,<span class="hljs-string">&quot;description&quot;</span>);
</code></pre>
<p>detects a type size of 1, since the underlying element type is a single string, so the minimum number of strings is 1.  But since it is a vector the expected number can be very big.  The default for a vector is (1&lt;&lt;30), and the allow_extra_args is set to true.  This means that at least 1 argument is expected to follow the option, but arbitrary numbers of arguments may follow.  These are checked if they have the form of an option but if not they are added to the argument.</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&gt; val;
app.add_option(<span class="hljs-string">&quot;--opt&quot;</span>,val,<span class="hljs-string">&quot;description&quot;</span>);
</code></pre>
<p>gets into the complicated cases where the type size is now 3.  and the expected max is set to a large number and <code>allow_extra_args</code> is set to true.  In this case at least 3 arguments are required to follow the option,  and subsequent groups must come in groups of three, otherwise an error will result.</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">bool</span> val{<span class="hljs-literal">false</span>};
app.add_flag(<span class="hljs-string">&quot;--opt&quot;</span>,val,<span class="hljs-string">&quot;description&quot;</span>);
</code></pre>
<p>Using the add_flag methods for creating options creates an option with an expected size of 0, implying no arguments can be passed.</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">complex</span>&lt;<span class="hljs-keyword">double</span>&gt; val;
app.add_option(<span class="hljs-string">&quot;--opt&quot;</span>,val,<span class="hljs-string">&quot;description&quot;</span>);
</code></pre>
<p>triggers the complex number type which has a min of 1 and max of 2,  so 1 or 2 strings can be passed.  Complex number conversion supports arguments of the form &quot;1+2j&quot; or &quot;1&quot;,&quot;2&quot;, or &quot;1&quot; &quot;2i&quot;.  The imaginary number symbols <code>i</code> and <code>j</code> are interchangeable in this context.</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; val;
app.add_option(<span class="hljs-string">&quot;--opt&quot;</span>,val,<span class="hljs-string">&quot;description&quot;</span>);
</code></pre>
<p>has a type size of 1 to (1&lt;&lt;30).</p>
<h3 id="customization">Customization</h3>
<p>The <code>type_size(N)</code>, <code>type_size(Nmin, Nmax)</code>, <code>expected(N)</code>, <code>expected(Nmin,Nmax)</code>, and <code>allow_extra_args()</code> can be used to customize an option.  For example</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> val;
<span class="hljs-keyword">auto</span> opt=app.add_flag(<span class="hljs-string">&quot;--opt{vvv}&quot;</span>,val,<span class="hljs-string">&quot;description&quot;</span>);
opt-&gt;expected(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);
</code></pre>
<p>will create a hybrid option, that can exist on its own in which case the value &quot;vvv&quot; is used or if a value is given that value will be used.</p>
<p>There are some additional options that can be specified to modify an option for specific cases</p>
<ul>
<li><code>-&gt;run_callback_for_default()</code> will specify that the callback should be executed when a default_val is set. This is set automatically when appropriate though it can be turned on or off and any user specified callback for an option will be executed when the default value for an option is set.</li>
</ul>
<h2 id="unusual-circumstances">Unusual circumstances</h2>
<p>There are a few cases where some things break down in the type system managing options and definitions.  Using the <code>add_option</code> method defines a lambda function to extract a default value if required.  In most cases this either straightforward or a failure is detected automatically and handled.  But in a few cases a streaming template is available that several layers down may not actually be defined.  The conditions in CLI11 cannot detect this circumstance automatically and will result in compile error.  One specific known case is <code>boost::optional</code> if the boost optional_io header is included.  This header defines a template for all boost optional values even if they do no actually have a streaming operator.  For example <code>boost::optional&lt;std::vector&gt;</code> does not have a streaming operator but one is detected since it is part of a template.  For these cases a secondary method <code>app-&gt;add_option_no_stream(...)</code> is provided that bypasses this operation completely and should compile in these cases.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="flags.html" class="navigation navigation-prev " aria-label="Previous page: Flags">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="validators.html" class="navigation navigation-next " aria-label="Next page: Validators">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Options","level":"1.5","depth":1,"next":{"title":"Validators","level":"1.6","depth":1,"path":"chapters/validators.md","ref":"chapters/validators.md","articles":[]},"previous":{"title":"Flags","level":"1.4","depth":1,"path":"chapters/flags.md","ref":"chapters/flags.md","articles":[]},"dir":"ltr"},"config":{"plugins":["include-codeblock","term","hints"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"search":{},"term":{"copyButtons":true,"fade":true,"lineStyles":true,"prompt":"(?<prompt>[^\\$^#^:]*)(?<pathsep>:?)(?<path>[^\\$^#]*?)(?<delimiter>[\\$#] )(?<command>.*)$","style":"default"},"hints":{"danger":"fa fa-exclamation-circle","info":"fa fa-info-circle","tip":"fa fa-mortar-board","working":"fa fa-wrench"},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"include-codeblock":{"check":false,"edit":false,"fixlang":true,"lang":"","template":"default","theme":"chrome","unindent":true},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Henry Schreiner","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CLI11 Tutorial","gitbook":"*","description":"A set of examples and detailed information about CLI11"},"file":{"path":"chapters/options.md","mtime":"2021-04-05T17:33:33.941Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2021-04-05T17:37:59.972Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-term/clipboard.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-term/initclip.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-term/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

